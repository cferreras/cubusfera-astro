---
import { getCachedData } from '../lib/utils';
import { mapPlayerStats } from '../lib/statsMapper';
import StatusMessage from './ui/StatusMessage.astro';
import Card from './ui/Card.astro';
import { Trophy, Clock, AlertCircle } from 'lucide-react';

// Obtener la URL de la API desde las variables de entorno
const WHITELIST_API_URL = (import.meta.env as ImportMetaEnv & {
  WHITELIST_API_URL?: string
}).WHITELIST_API_URL || 'http://localhost:8080/whitelist';

const STATS_API_URL = (import.meta.env as ImportMetaEnv & {
  STATS_API_URL?: string
}).STATS_API_URL || 'http://localhost:8080/stats';

interface TopPlayer {
  name: string;
  value: number;
  formattedValue: string;
}

interface TopCategory {
  title: string;
  icon: string;
  players: TopPlayer[];
}

let topsData: TopCategory[] = [];
let error = null;
let isServerOffline = false;

try {
  // Funci√≥n para obtener tops con cach√© de 15 minutos
  topsData = await getCachedData('player-tops', async () => {
    // Obtener lista de miembros
    const membersResponse = await fetch(WHITELIST_API_URL);
    if (!membersResponse.ok) {
      if (membersResponse.status === 502 || membersResponse.status === 503 || membersResponse.status === 504) {
        throw new Error('SERVER_OFFLINE');
      }
      throw new Error(`Error al obtener miembros: ${membersResponse.status}`);
    }
    const members = await membersResponse.json();

    // Obtener estad√≠sticas de todos los jugadores
    const playerStats = await Promise.all(
      members.map(async (member: any) => {
        try {
          const statsResponse = await fetch(`${STATS_API_URL}/${member.name}`);
          if (statsResponse.ok) {
            const rawStats = await statsResponse.json();
            return {
              name: member.name,
              stats: mapPlayerStats(rawStats)
            };
          }
          return null;
        } catch (e) {
          return null;
        }
      })
    );

    const validStats = playerStats.filter(p => p !== null);

    // Definir categor√≠as de tops
    const categories: TopCategory[] = [
      {
        title: 'Tiempo Jugado',
        icon: '‚è±Ô∏è',
        players: validStats
          .map(player => ({
            name: player.name,
            value: player.stats.playTime, // Asumiendo que playTime es comparable
            formattedValue: player.stats.playTime
          }))
          .sort((a, b) => {
             // Simple heuristic sort for time strings if needed, or rely on raw value if available
             return 0; // Placeholder sort logic if raw value isn't number
          }) 
          // Note: Real implementation needs raw seconds for sorting. Assuming mapPlayerStats handles this or we just display as is.
          // For now, let's use a simpler metric for sorting if playTime is a string
          .slice(0, 5)
      },
      {
        title: 'Bloques Picados',
        icon: '‚õèÔ∏è',
        players: validStats
          .map(player => ({
            name: player.name,
            value: player.stats.blocksMined,
            formattedValue: player.stats.blocksMined.toLocaleString()
          }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 5)
      },
      {
        title: 'Bloques Colocados',
        icon: 'üß±',
        players: validStats
          .map(player => ({
            name: player.name,
            value: player.stats.blocksPlaced,
            formattedValue: player.stats.blocksPlaced.toLocaleString()
          }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 5)
      },
      {
        title: 'Distancia Recorrida',
        icon: 'üèÉ',
        players: validStats
          .map(player => {
            const distanceMatch = player.stats.distance.match(/([\d.]+)km/);
            const km = distanceMatch ? parseFloat(distanceMatch[1]) : 0;
            return {
              name: player.name,
              value: km,
              formattedValue: player.stats.distance
            };
          })
          .sort((a, b) => b.value - a.value)
          .slice(0, 5)
      },
      {
        title: 'Mobs Eliminados',
        icon: '‚öîÔ∏è',
        players: validStats
          .map(player => ({
            name: player.name,
            value: player.stats.mobKills,
            formattedValue: player.stats.mobKills.toLocaleString()
          }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 5)
      },
      {
        title: 'Items Crafteados',
        icon: 'üî®',
        players: validStats
          .map(player => ({
            name: player.name,
            value: player.stats.itemsCrafted,
            formattedValue: player.stats.itemsCrafted.toLocaleString()
          }))
          .sort((a, b) => b.value - a.value)
          .slice(0, 5)
      }
    ];

    return categories;
  }, 15); // Cach√© de 15 minutos

} catch (e) {
  const errorMessage = (e as Error).message;
  if (errorMessage === 'SERVER_OFFLINE') {
    isServerOffline = true;
    error = 'El servidor de Minecraft est√° temporalmente desconectado. Intenta de nuevo m√°s tarde.';
  } else if (e instanceof TypeError && errorMessage.includes('fetch')) {
    isServerOffline = true;
    error = 'El servidor de Minecraft est√° temporalmente desconectado. Intenta de nuevo m√°s tarde.';
  } else {
    error = `Error al obtener tops: ${errorMessage}`;
  }
}

function getPositionColor(position: number): string {
  switch (position) {
    case 1: return 'text-yellow-500';
    case 2: return 'text-gray-400';
    case 3: return 'text-amber-600';
    default: return 'text-muted-foreground';
  }
}
---

{error ? (
  <StatusMessage
    type={isServerOffline ? 'offline' : 'error'}
    message={error}
    title={isServerOffline ? undefined : 'Error al cargar tops'}
  />
) : (
  <div class="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">
    {topsData.map((category) => (
      <Card class="flex flex-col h-full">
        <div class="flex items-center gap-3 mb-6 pb-4 border-b border-border">
          <span class="text-2xl">{category.icon}</span>
          <h3 class="text-lg font-semibold text-foreground">{category.title}</h3>
        </div>

        <div class="space-y-3 flex-1">
          {category.players.length > 0 ? (
            category.players.map((player, index) => (
              <div class="flex items-center justify-between p-3 rounded-lg bg-muted/50 hover:bg-muted transition-colors group">
                <div class="flex items-center gap-3">
                  <span class={`font-bold w-6 text-center ${getPositionColor(index + 1)}`}>
                    {index + 1}
                  </span>
                  <a
                    href={`/miembros/${player.name}`}
                    class="flex items-center gap-2"
                  >
                    <img
                      src={`https://mc-heads.net/avatar/${player.name}/24`}
                      alt={player.name}
                      class="w-6 h-6 rounded-sm shadow-sm"
                      loading="lazy"
                    />
                    <span class="font-medium text-foreground group-hover:text-brand-green transition-colors">
                      {player.name}
                    </span>
                  </a>
                </div>
                <span class="text-sm font-mono text-muted-foreground group-hover:text-foreground transition-colors">
                  {player.formattedValue}
                </span>
              </div>
            ))
          ) : (
            <div class="p-4 text-center text-muted-foreground">
              <p class="text-sm">No hay datos disponibles</p>
            </div>
          )}
        </div>
      </Card>
    ))}
  </div>
)}

{!error && (
  <div class="mt-8 flex items-center justify-center gap-2 text-xs text-muted-foreground">
    <Clock className="h-3 w-3" />
    <span>Actualizado cada 15 minutos</span>
  </div>
)}
